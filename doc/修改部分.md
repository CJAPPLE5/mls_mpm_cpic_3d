魔改部分主要是CPIC里，以平面为基准划分点(标记color)的方式。mpm的流程以及对不同color点的处理方式没咋改。

我就简单讲一下mls-mpm的流程，以及我修改的部分，顺便看看理解是否有误。

### 一、CDF

#### 1.1 grid

标记grid与particle的过程。论文里是将每个grid投影到rigid_seg的直线上，判断其是否在线段内，以标记grid_A（是否受到切割），以及利用叉乘判断grid在切割线左右。

在3维情况下，seg为面，仿照二维方法。将每个seg的particle设为三角形三个顶点的重心位置（三点坐标求平均），面的覆盖范围，就是三个顶点覆盖范围。在read_obj函数里有所体现。

判断grid是否在seg的覆盖范围内，方法是先将点投影至seg所在平面，在利用叉乘判断是否在三角形内，实现函数为isinplane()，存入condi变量。

求解距离d则是直接用几何方法，类似于sdf。直接求解grid到圆环上的距离。实现函数为getdistance_i()。(求解点到圆环距离函数为getdistance_p)。

还要获取grid离最近的seg的法向normal。刚开始我是使用seg面的法向，后来感觉点太少比较粗糙，于是改成了几何方法，也是类似于sdf，直接求解grid到圆环的法向。实现函数为getnormal_i()。

与薄板切割不同的是，圆环切割并不是所有部分都起到切割作用的。比如向下切割时，上半部分被下半部分遮挡，不起切割作用。于是我在condi的基础上增加一个条件，就是判断noraml方向与移动方向的叉乘大于0，才会对grid有切割效果。

#### 1.2 particle

p_A即周围27个grid，有一个被切割就标记为1。这部分保持一致。

p_T，与计算grid_T方法类似，也是用几何方法判断点在环内还是环外(getT_p)。在代码实现时，将环内标为红色，环外标为绿色，不受影响的particle标为蓝色。

p_n，也是几何方法，见getnormal_p。

p_d，同样几何方法，见getnormal_p。

之前使用的是MLS那一套计算p_n与p_d，因为编译时间和计算实在太长，于是改成了几何方法直接计算。



### 二、P2G

P2G部分没啥改动，判断grid与particle是否匹配，不匹配直接跳过即可。

为了让切割的时候，方块不乱跑，我直接将底座那几层(j<3)的部分，速度设为0。不知道这样处理是否合理。



### 三、G2P

改动的第一个部分是g_v的选择。按照论文所说，对不匹配的grid与particle，先判断速度差与点的法向内积，即判断远离还是相撞。如果远离(>0)，直接用粒子速度v_p代替；如果相撞，则更新为grid速度加上速度差在碰撞面的切向。如果想要切割两侧相互y远离，g_v再加上dt\*c\*p_n，为了效果明显我也加了。但是发现c设置过大，粒子抖动有点明显，十分抽搐。

还有f_penalty，公式继续沿用论文的，只是kh比fan_rotation实现文件的kh小了好几个数量级。要不然也会非常抽搐，然后爆炸。



#### 四、其他

在计算点到圆环法向的时候，发现大多数点，相距圆环非常近，且大多数在圆环正下方，以至于计算出来的normal的y分量非常大，以至于占0.9（归一化后），且很多点都是如此（我也不知道为啥），以至于圆环往下移动，点不是被切开向两边走，而是直接被压扁了。于是我做了一个smooth（也可以说强行让点散开），把normal的第二个分量除以20，然后再归一化，使得各个方向分布均匀。



